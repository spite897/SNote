# buildLog
- program: **Shell_Basis** 
- from: **runoob** 
- status: **done** 

**===============================0.基本語法====================================**

```sh
# 單行註釋
{函數代碼塊的多行註釋
}

:<<<FLAG>
Here文檔的多行註釋
<FLAG>

:<<<"Here String"

: '
使用給空命令: 傳遞參數的多行註釋
'
```

> #!/bin/<interpreter>  指定解釋器
> - `chmod +x <sh_script>`      : 給予執行權限
> - `sh <sh_script>`            : 傳遞給解釋器

**===============================1.數據類型====================================**

### 變量聲明 只讀變量 刪除變量 指定變量類型

```sh
# 等號兩邊不允許空格
a="asd"
# 使用變量需要加 $ 符號
echo ${a}

readonly a
# 刪除變量 不能刪除只讀變量
unset a

declare -i var_int
```

### 數組 關聯數組

不支持多維數組

```sh
var_array=(1 2 3 4 5)
a2=({1..9})

declare -A var_associative_array=(["k1"]="v2")
var_associative_array["k1"]="v1"
var_associative_array["k2"]=2
echo ${var_associative_array["k1"]}
```

> - 使用 `array[@]` 或 `array[*]`           獲取所有元素
> - 使用 `!array[@]` 或 `!array[*]`         獲取所有鍵
> - 使用 `${#array[*]}` 或 `${#array[@]}`   獲取數組長度

### 關於常量

- $0    : 腳本名稱
- $1... : 腳本參數
- $$    : 腳本ID
- $*    : "$1 $2 ...$n" - `一個字符串`
- $@    : "$1" "$2" ... "$n" 
- $#    : 參數數量
- $?    : 上個命令退出狀態
- $-, $!

> `$@` 相比 `"$@"` 會展開參數
> - `"$@"`   : "1 2" "2 3"
> - `$@` : 1 2 2 3

### 關於字符串

`使用'的字符串`
- 轉義字符無效
- 無法使用變量（相對與"")
- 兩種都可以拼接字符串

```sh
# 正常寫法
v="string, ${var2}asd"
v="string, "${var2}"asd"
v='string, '${var2}'asd'
# 無法解析變量
v='string, ${var2}'
```

> - 使用 `${#str}` 或 `${#str[0]}`         獲取字符串長度
> - 使用 `expr index "$str" <char>`      查找子字符串 返回最先出現的字符索引+1 或0 
> - 截取字符
> - - 使用 `${str:<index>:<length>}`     根據索引
> - - 使用 `str#<regexp>`                保留正則右側 開區間 ; `##` 以從尾部開始匹配
> - - 使用 `str%<regexp>`                保留正則左側 開區間 ; `%%` 以從頭部開始匹配
> - `str/old/new`                        替換字符
> - - `str/%old/new` 以從尾部開始匹配
> - - `str//old/new` 以全部替換

**================================3.運算符=====================================**

| char           | desc               | e.g.                                 |
| -              | -                  | -                                    |
| 算術運算符     | --                 | --                                   |
| +-*/%          | *符號應轉義\\ \*   | \`expr $a \* $b \` or $(( $a * $b )) |
| == !=          |                    | [ $a == $b ]                         |
| 關係運算符     | --                 | --                                   |
| -eq -ne        | 相等 / 不等        | [ $a -eq $b ]                        |
| -gt -ge        | 大於 / 不小於      |                                      |
| -lt -le        | 小於 / 不大於      |                                      |
| 布爾運算符     | --                 | --                                   |
| !              | 非                 | [ ! false ]                          |
| -a -o          | 與 / 或            | [ true -o false ]                    |
| 邏輯運算符     | --                 | --                                   |
| && \|\|        |                    | [[ true && false ]]                  |
| 字符串運算符   | --                 | --                                   |
| = !=           | 相等               | [ $a = $b ]                          |
| -z -n          | 長度爲0 / 不爲零   | [ -n "$a" ]                          |
| $              | 是否不爲空         | [ $a ]                               |
| 文件測試運算符 | --                 | --                                   |
| -r -w -x       | 讀取 寫入 可執行   | [ -r file ]                          |
| -d -s -e       | 爲目錄 不爲空 存在 |                                      |
| -f -L ...      | 爲普通文件 爲鏈接  |                                      |

### 關於運行運算符的方法

- awk expr let 等命令
- $(()) 語法

```sh
let num++
((num++))
num=$((num + 1))
num=$(expr $num + 1)
```

> - 使用 [\[]] 代替 [] 以提高代碼穩定性
> - (($a >= $b))

**===============================4.Shell命令===================================**

| cmd         | desc                                                             | e.g. |
| -           | -                                                                | -    |
| echo        | -n 禁止添加換行符 ; -e 啓用轉義字符                              |      |
| read        | -p "" 提示信息 ; -n num 限制位數 ; -t num 限制事件 ; -s 隱藏輸入 |      |
| test or [ ] | 詳見3.運算符                                                     |      |
| seq         | 生成序列                                                         |      |

### 關於特殊語法

**()**
- 在獨立終端執行其中的命令

**[\[ ]]**
- 支持模式匹配  :   `[[ "$var" == *.txt ]]`
- 支持正則      :   `[[ "$var" =~ ^[0-9]+$ ]]`
- 字符串處理

(())
- 算數處理

> - 使用printf代替echo以提高可移植性
 
**===============================5.流程控制====================================**

```sh
if condition
then
    commandx
: '
elif condition
then cmd
else
    commands
'
fi

for var in a b c 
do
    cmd
done

for((i=1;i<=5;i++));do
    cmd
done

while condition
do
    cmd
done

until condition
do
    cmd
done

case $var in
<v1>) cmd
;;
<v2>) cmd
;;
*) cmd
;;
esac
```

> 0 代表 true ; 0外代表false

**=================================6.函數======================================**

```sh
[function] funcName[()]{
    cmd
    [return]
}
```

> - 使用`$?`訪問返回值
> - 返回值只能是[0-255]的整數

**================================7.重定向=====================================**

```sh
# 重定向標準錯誤到文件
command 2> file
# 先重定向標準輸出到file 再使{ 標準錯誤 = 標準輸出 }
command > file 2>&1
# 等效於上面的寫法
command &> file
```

> - 文件描述符0 1 2 分別對於 標準輸入 輸出 錯誤
> - 將輸出重定向到`/dev/null` 即垃圾桶文件

### 命名管道

```sh
mkfifo file
cat > file
wc -l < file
```

> `exec 2>file` 以将终端的错误输出重定向

-----------------------------------------------------------------------------
