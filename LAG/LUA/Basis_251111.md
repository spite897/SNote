# buildLog
- program: **Lua_Basis** 
- from: **runoob** 
- status: **done** 

**===============================1.基本語法====================================**

```lua
#!/usr/local/bin/lua
-- 指定解釋器 用於快捷執行腳本

print("Hello World")

--[=[ 
-- 改爲三連 - 符號可以用於啓用/禁用多行註釋中的代碼

multi statement

--]=]
```

> 一般約定`__ups`被保留用於Lua內部全局變量

**===============================2.數據類型====================================**

| type     | desc              |
| -        | -                 |
| nil      | 未定義；值爲false |
| boolean  |                   |
| number   | double            |
| string   | '' or "" or [[]]  |
| function | C or Lua function |
| userdata | C 數據結構        |
| thread   |                   |
| table    |                   |

> type() 用於返回一個變量類型的 string   
 
**關於 boolean** 
- { nil, false } => false  ;  0=>true


**關於 string**
- 使用 .. 鏈接字符串
- 字符串+-運算會轉換爲number類型
- 使用 # 獲得字符串長度
- 使用 [[]] 創造跨行字符

關於 table
- 索引從1開始
- 解除所有引用後 lua垃圾回收會釋放內存
- `gettable_evnet(table, index)`

關於賦值
- 允許多個變量同時賦值 先計算結果再進行賦值

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

### Table操作

| func                                       | desc                                                                   |
| -                                          | -                                                                      |
| table.concat(table[, sep[, start[, end]]]) | 將 Table 數組部分指定位置元素連接成字符串並返回 以sep爲間隔 缺省sep="" |
| table.insert(table,[pos,] value)           | 缺省pos=-1                                                             |
| table.remove(table[, pos])                 | 返回並刪除 缺省pos=-1                                                  |
| table.sort(table[, comp])                  | 缺省升序排列                                                           |

> `concatenate` 
 
**=================================3.循環======================================**

```lua
while(<condition>) do
    <statements>
end

for i=1, 10, 1 do   --  結尾值會在進入循環時確定
    <statements>
end

for k,v in table do
    <statements>
end

repeat              -- do while(! <condition>)
    <statements>
until(<condition>)
```

**關於 pairs() ipairs()** 
- pairs() 先遍歷數字索引 再遍歷標識索引
- ipairs() 僅遍歷數字索引

> 不存在continue 

**=================================4.函數======================================**

支持特性
- 多返回值
- 可變參數

```lua

-- 多返回值
function func()
    return a, b
end
-- 多返回值不被接收的部分會被捨棄
-- exp : func(), func()   =>  (a, b), (a, b)
-- => a, a, b

-- 可變參數
function <func_name>(recv, ...)
    local args = {...}
    -- 創建一個表
    select("#", ...)
    -- 獲取參數數量
    select(n, ...)
    -- 從 n 開始到結束位置的參數 
    -- exp : select(2, 1, 2, 3, 4) => 2, 3, 4
end

```

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

> 邏輯運算符比較布爾值並返回原值且短路求值 因而可用於實現三目運算
> **!!! 這種寫法在 B = false 時會失效**
> - `<condition> and <TrueS> or <FalseS>`
> - - A and B : A=false ? A : B
> - - A or B  : A=true  ? A : B
> 
> Object:func() 
> => Object.func(Object)

**============================5.迭代器及泛型for================================**

`for iterator`

`for <vars> in func() do <statement> end` =>

`for <vars> in <迭代函數>,<狀態常量>,<控制變量> do <statement> end` =>

**Loop** `<vars> = <迭代函數>(<狀態常量>, <控制變量>)` && `返回的第一個值不爲nil`
do `<statement>` end

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

1. **無狀態的迭代器**

```lua
-- ipairs函數的一種實現
function iter(table, index)
    index = index + 1
    local v = table[index]
    if v != nil then
        return index, v
    end
end
function ipairs(table)
    return iter, table, 0
end
```

2. **多狀態的迭代器**
 
即需要保存多個狀態信息
 
```lua
--使用閉包實現的多狀態迭代器
function ipairs(table)
    local index = 0
    local count = #table
    
    return function()
        index = index + 1
        if index <= count then
            return index, table[index]
        end
    end
end
```

**==================================6.模塊=====================================**

`編寫模塊`

```lua
-- <module_file_name>
<pack_name> = {}
-- ...定義等等
return <pack_name>
```

`使用模塊`

```lua
require "<module_file_name>"
```

> require 載入文件並執行代碼塊 相同文件只執行一次

**==================================7.元表=====================================**

元表作用是改變表的行爲。
`表` 與 `其元表` 類似與 `實例` 與 `類` 的關係。

- **setmetatable( t, mt )** : 設置mt爲t的元表 返回t
- getmetatable( t )     : 返回t的元表

> 表只有一個元表
> 元表不能嵌套 即元表不能有元表
> 雙下劃線__metatable 屬性儲存元表地址

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

- **關於元表的鍵值**

*以下敘述相對 表t 及 其元表mt*

1. 雙下劃線__index

通過鍵k訪問t時，如果t沒有對於值，則會返回__index[k]或__index( t, k )。（對應爲表與方法）

```
t.k 
=> t.k~=nil ? t.k ; ( mt.__index.k or mt.__index( t, k ) )
```

2. 雙下劃線__newindex

給t的空鍵k賦值時，會改爲 mt.__newindex[k]=v 或 mt.__newindex(t, k, v)。（對應表與方法時）

```
t[k] = v
=> if t[k] ~= nil   t[k] = v
else                ( mt.__newindex[k] = v) or ( mt.__newindex(t, k, v) )
```

3. 運算符重構

__add, __sub, __mul, __div, __mod, __pow

|          |      |
| -        | -    |
| __unm    | 取負 |
| __concat | ..   |
| __eq     | ==   |
| __lt     | <    |
| __le     | <=   |

> 其他關係運算符會轉化爲上三種
> 在函數中修改表是全局的，爲了穩定性請在方法中創建複製並返回。

4. 雙下劃線__call

調用t時，改爲mt.__call(<arg>)。

5.雙下劃線__tostring

**==================================8.協同=====================================**

子集於線程，主要區別在於不能同時運行多個線程，需要彼此協作運行。

| func                   | desc                                       |
| -                      | -                                          |
| create( func )         | 創建並返回協同                             |
| resume( crot, [args] ) | 重啓協同 以及傳遞參數                      |
| yield( msg )           | 掛起協同 對外返回msg 對內返回接收數據      |
| status()               | 查看協同狀態(dead,  suspended, running )   |
| wrap( func )           | 創建並將協同打成函數                       |
| running()              | 返回正在運行的coroutine                    |

### 關於 yield 與 resume 參數的傳遞

```lua
local CROT = coroutine.create( function( a )
    local recv = yield("Y_MSG")
    return a , recv
end)

coroutine.resume(CROT, "R_MSG1")
-- 返回 true, "Y_MSG"
coroutine.resume(CROT, "R_MSG2")
-- 返回 true, "R_MSG1", "R_MSG2"
coroutine.resume(CROT)
-- 返回 false, "cannot resume dead coroutine"
```

**=================================9.文件IO====================================**

| funcs                          | desc                                        |
| -                              | -                                           |
| open(<name>, <mode>)           | 返回文件對象                                |
| input(f) ; output(f)           | 設置默認輸入/輸出文件（用於訪問單個文件時） |
| read([flag])                   |                                             |
| close(f)                       |                                             |
| write(f, <text>)               |                                             |
| tmpfile()                      | 返回一個臨時文件 以a打開                    |
| type(f)                        | 檢測是否可用                                |
| flush()                        | 寫入緩衝中的數據                            |
| lines(<name>)                  | 返回一個讀取迭代器 一次讀取一行             |
| seek(f, whence, offset)        | 設置光標並返回位置                          |

### 關於flag whence

| flag       | desc            |
| -          | -               |
| **flag**   | --              |
| "*n"       | 讀取一個數字    |
| "*a"       | 讀取全部        |
| "<pipe>"   | 讀取一行 缺省值 |
| number     | 讀取指定字符數  |
| **whence** | --              |
| "set"      | 頭              |
| "cur"      | 當前位置        |
| "end"      | 尾              |

> mode : `w, a, r` & `+, b`

-----------------------------------------------------------------------------
